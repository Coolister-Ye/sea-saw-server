name: Deploy to Tencent Cloud Production

on:
  push:
    branches:
      - main
      - production
  workflow_dispatch:  # ÂÖÅËÆ∏ÊâãÂä®Ëß¶Âèë
    inputs:
      build_mode:
        description: 'Build mode: registry (build and push to registry) or local (build on server)'
        required: false
        default: 'local'
        type: choice
        options:
          - local
          - registry

env:
  DOCKER_REGISTRY: hkccr.ccs.tencentyun.com  # ËÖæËÆØ‰∫ëÂÆπÂô®ÈïúÂÉèÊúçÂä° (Hong Kong)
  IMAGE_NAMESPACE: sea-saw  # ÂëΩÂêçÁ©∫Èó¥
  IMAGE_NAME: backend
  # Default to 'local' mode for push events, use input for manual triggers
  BUILD_MODE: ${{ github.event.inputs.build_mode || 'local' }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd app
          pip install -r requirements.txt

      - name: Run linting
        run: |
          cd app
          pip install flake8
          flake8 --ignore=E501,F401,W503,F811,E402,E203 .

      - name: Run tests
        run: |
          cd app
          python manage.py test

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production') && github.event.repository.default_branch != '' && (github.event.inputs.build_mode == 'registry' || (github.event_name == 'push' && vars.BUILD_MODE == 'registry'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Tencent Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.TCR_USERNAME }}
          password: ${{ secrets.TCR_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/compose/prod/django/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    name: Deploy to Tencent Cloud Server
    runs-on: ubuntu-latest
    needs: test
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production') && always() && needs.test.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.TENCENT_SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
        run: |
          mkdir -p ~/.ssh
          echo "Adding server ${SERVER_IP} to known hosts..."
          ssh-keyscan -H ${SERVER_IP} >> ~/.ssh/known_hosts 2>&1
          chmod 644 ~/.ssh/known_hosts
          echo "Known hosts configured"

      - name: Test SSH connection
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
          SERVER_USER: ${{ secrets.TENCENT_SERVER_USER }}
        run: |
          echo "Testing SSH connection to ${SERVER_USER}@${SERVER_IP}..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_IP} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed. Please check:"
            echo "  1. TENCENT_SSH_PRIVATE_KEY secret is correctly configured"
            echo "  2. TENCENT_SERVER_IP and TENCENT_SERVER_USER are correct"
            echo "  3. Server allows SSH key authentication"
            exit 1
          }

      - name: Copy deployment files
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
          SERVER_USER: ${{ secrets.TENCENT_SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          BUILD_MODE: ${{ env.BUILD_MODE }}
        run: |
          echo "üì¶ Copying deployment files to server (mode: ${BUILD_MODE})..."

          # Â§çÂà∂Â∫îÁî®‰ª£Á†Å (‰ªÖÂú® local Ê®°Âºè)
          if [ "${BUILD_MODE}" = "local" ]; then
            echo "Copying app directory for local build..."
            rsync -avz --delete \
              --exclude='*.pyc' \
              --exclude='__pycache__' \
              --exclude='.git' \
              --exclude='*.sqlite3' \
              --exclude='staticfiles' \
              --exclude='mediafiles' \
              app/ ${SERVER_USER}@${SERVER_IP}:${DEPLOY_PATH}/app/
          else
            echo "Skipping app directory copy (using registry images)"
          fi

          # Â§çÂà∂ docker-compose ÂíåÈÖçÁΩÆÊñá‰ª∂
          echo "Copying docker-compose and config files..."
          scp docker-compose.prod.yml ${SERVER_USER}@${SERVER_IP}:${DEPLOY_PATH}/

          if [ -d "nginx" ]; then
            scp -r nginx ${SERVER_USER}@${SERVER_IP}:${DEPLOY_PATH}/
          fi

          if [ -f "deploy.sh" ]; then
            scp deploy.sh ${SERVER_USER}@${SERVER_IP}:${DEPLOY_PATH}/
            ssh ${SERVER_USER}@${SERVER_IP} "chmod +x ${DEPLOY_PATH}/deploy.sh"
          fi

          echo "‚úÖ Files copied successfully"

      - name: Deploy to production
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
          SERVER_USER: ${{ secrets.TENCENT_SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          BUILD_MODE: ${{ env.BUILD_MODE }}
          TCR_USERNAME: ${{ secrets.TCR_USERNAME }}
          TCR_PASSWORD: ${{ secrets.TCR_PASSWORD }}
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
        run: |
          ssh -o ConnectTimeout=30 ${SERVER_USER}@${SERVER_IP} bash << ENDSSH
            set -e
            cd ${DEPLOY_PATH}

            # ËÆæÁΩÆÁªü‰∏ÄÁöÑÈ°πÁõÆÂêçÁß∞
            export COMPOSE_PROJECT_NAME=sea_saw_prod

            echo "üöÄ Starting deployment (mode: ${BUILD_MODE})..."

            # Â§á‰ªΩÊï∞ÊçÆÂ∫ì
            echo "üíæ Backing up database..."
            ./deploy.sh backup || echo "‚ö†Ô∏è Backup failed, continuing..."

            # ÂÅúÊ≠¢ÊóßÊúçÂä°Âπ∂Ê∏ÖÁêÜ
            echo "üõë Stopping old services..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml down --remove-orphans

            # Ê∏ÖÁêÜÂèØËÉΩÂç†Áî®Á´ØÂè£ÁöÑÂ≠§Á´ãÂÆπÂô®
            echo "üßπ Cleaning up containers that might be using critical ports..."
            docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E '6379|5432|8000|5555' | awk '{print \$1}' | grep -v CONTAINER | xargs -r docker rm -f || true

            # Á°Æ‰øùÂÖ≥ÈîÆÁ´ØÂè£Â∑≤ÈáäÊîæ
            echo "üîç Verifying critical ports are free..."
            sleep 3
            for port in 6379 5432 8000 5555; do
              if netstat -tuln 2>/dev/null | grep -q ":\$port " || ss -tuln 2>/dev/null | grep -q ":\$port "; then
                echo "‚ö†Ô∏è Port \$port still in use, attempting to free it..."
                fuser -k \$port/tcp 2>/dev/null || true
                sleep 2
              else
                echo "‚úÖ Port \$port is free"
              fi
            done

            # Ê†πÊçÆÊ®°ÂºèÈÄâÊã©ÈÉ®ÁΩ≤ÊñπÂºè
            if [ "${BUILD_MODE}" = "registry" ]; then
              # Registry Ê®°ÂºèÔºöÁôªÂΩïÂπ∂ÊãâÂèñÈïúÂÉè
              echo "üîê Logging in to Tencent Container Registry..."
              echo "${TCR_PASSWORD}" | docker login ${DOCKER_REGISTRY} -u "${TCR_USERNAME}" --password-stdin

              echo "üì• Pulling latest Docker images from registry..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml pull

              echo "üöÄ Starting services with registry images..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml up -d
            else
              # Local Ê®°ÂºèÔºöÊú¨Âú∞ÊûÑÂª∫
              echo "üî® Building and starting services locally..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml up -d --build
            fi

            # Á≠âÂæÖÊúçÂä°Â∞±Áª™
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30

            # ËøêË°åÊï∞ÊçÆÂ∫ìËøÅÁßª
            echo "üóÑÔ∏è Running database migrations..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml exec -T web python manage.py migrate --noinput

            # Êî∂ÈõÜÈùôÊÄÅÊñá‰ª∂
            echo "üì¶ Collecting static files..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput

            # Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ
            echo "üè• Checking service health..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml ps

            # Ê∏ÖÁêÜÊóßÈïúÂÉè
            echo "üßπ Cleaning up old images..."
            docker image prune -af --filter "until=72h"

            echo "‚úÖ Deployment completed successfully!"
          ENDSSH

      - name: Health check
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
        run: |
          echo "üè• Performing health check..."
          max_retries=5
          retry_count=0

          until curl -f http://${SERVER_IP}:8000/health/ || [ $retry_count -eq $max_retries ]; do
            echo "‚è≥ Waiting for service to be ready... ($retry_count/$max_retries)"
            retry_count=$((retry_count + 1))
            sleep 10
          done

          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Health check failed!"
            exit 1
          fi

          echo "‚úÖ Service is healthy!"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production')

    steps:
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.TENCENT_SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
        run: |
          mkdir -p ~/.ssh
          echo "Adding server ${SERVER_IP} to known hosts..."
          ssh-keyscan -H ${SERVER_IP} >> ~/.ssh/known_hosts 2>&1
          chmod 644 ~/.ssh/known_hosts
          echo "Known hosts configured"

      - name: Test SSH connection
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
          SERVER_USER: ${{ secrets.TENCENT_SERVER_USER }}
        run: |
          echo "Testing SSH connection to ${SERVER_USER}@${SERVER_IP}..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_IP} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed. Please check:"
            echo "  1. TENCENT_SSH_PRIVATE_KEY secret is correctly configured"
            echo "  2. TENCENT_SERVER_IP and TENCENT_SERVER_USER are correct"
            echo "  3. Server allows SSH key authentication"
            exit 1
          }

      - name: Rollback deployment
        env:
          SERVER_IP: ${{ secrets.TENCENT_SERVER_IP }}
          SERVER_USER: ${{ secrets.TENCENT_SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh -o ConnectTimeout=30 ${SERVER_USER}@${SERVER_IP} bash << ENDSSH
            cd ${DEPLOY_PATH}

            # ËÆæÁΩÆÁªü‰∏ÄÁöÑÈ°πÁõÆÂêçÁß∞
            export COMPOSE_PROJECT_NAME=sea_saw_prod

            echo "‚ö†Ô∏è Deployment failed, rolling back..."

            # Âº∫Âà∂ÂÅúÊ≠¢Âπ∂ÁßªÈô§ÊâÄÊúâÁõ∏ÂÖ≥ÂÆπÂô®ÔºàÂåÖÊã¨‰ΩøÁî®Á´ØÂè£ÁöÑÂÆπÂô®Ôºâ
            echo "üõë Forcefully stopping all containers..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml down --remove-orphans --volumes || true

            # Ê∏ÖÁêÜÂèØËÉΩÂç†Áî®Á´ØÂè£ÁöÑÂ≠§Á´ãÂÆπÂô®
            echo "üßπ Cleaning up containers that might be using critical ports..."
            # Êü•ÊâæÂπ∂ÂÅúÊ≠¢ÊâÄÊúâÂèØËÉΩÂç†Áî®ÂÖ≥ÈîÆÁ´ØÂè£ÁöÑÂÆπÂô®
            docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E '6379|5432|8000|5555' | awk '{print \$1}' | grep -v CONTAINER | xargs -r docker rm -f || true

            # Ê∏ÖÁêÜÊâÄÊúâÂ∑≤ÂÅúÊ≠¢ÁöÑÂÆπÂô®
            docker container prune -f || true

            # Á°Æ‰øùÁ´ØÂè£Â∑≤ÈáäÊîæ
            echo "üîç Verifying ports are free..."
            sleep 3
            for port in 6379 5432 8000 5555; do
              if netstat -tuln 2>/dev/null | grep -q ":\$port " || ss -tuln 2>/dev/null | grep -q ":\$port "; then
                echo "‚ö†Ô∏è Port \$port still in use. Checking process..."
                # Â∞ùËØïÊâæÂà∞Âπ∂ÁªàÊ≠¢Âç†Áî®Á´ØÂè£ÁöÑËøõÁ®ã
                fuser -k \$port/tcp 2>/dev/null || true
                sleep 2
              else
                echo "‚úÖ Port \$port is free"
              fi
            done

            # ÊÅ¢Â§çÊúÄÊñ∞Â§á‰ªΩ
            echo "üîÑ Restoring latest backup..."
            LATEST_BACKUP=\$(ls -t backups/backup_*.sql.gz 2>/dev/null | head -1)
            if [ -n "\$LATEST_BACKUP" ]; then
              # ÂêØÂä®Êï∞ÊçÆÂ∫ìÊúçÂä°
              echo "üóÑÔ∏è Starting database service..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml up -d db
              sleep 10

              # ÊÅ¢Â§çÊï∞ÊçÆÂ∫ì
              echo "üì• Restoring database from backup..."
              gunzip -c "\$LATEST_BACKUP" | docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml exec -T db psql -U sea_saw_prod_user sea_saw_prod
              echo "‚úÖ Database restored from backup"

              # ÂêØÂä®ÊâÄÊúâÊúçÂä°
              echo "üöÄ Starting all services..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml up -d
            else
              echo "‚ö†Ô∏è No backup found, attempting to restart existing services..."
              docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml up -d || {
                echo "‚ùå Failed to start services. Manual intervention required."
                exit 1
              }
            fi

            # Á≠âÂæÖÊúçÂä°ÂêØÂä®
            echo "‚è≥ Waiting for services to stabilize..."
            sleep 20

            # Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ
            echo "üè• Checking service status..."
            docker compose -p \${COMPOSE_PROJECT_NAME} -f docker-compose.prod.yml ps

            echo "‚úÖ Rollback completed"
          ENDSSH

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [test, build-and-push, deploy]
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.test.result }}" != "success" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Sea-Saw ÂêéÁ´ØÊµãËØïÂ§±Ë¥•" >> $GITHUB_OUTPUT
            echo "details=ÊµãËØïÈò∂ÊÆµÂ§±Ë¥•ÔºåÊú™ËøõË°åÈÉ®ÁΩ≤" >> $GITHUB_OUTPUT
          elif [ "${{ needs.build-and-push.result }}" == "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Sea-Saw ÂêéÁ´ØÈïúÂÉèÊûÑÂª∫Â§±Ë¥•" >> $GITHUB_OUTPUT
            echo "details=ÈïúÂÉèÊûÑÂª∫Â§±Ë¥•ÔºåÊú™ËøõË°åÈÉ®ÁΩ≤" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=‚úÖ Sea-Saw ÂêéÁ´ØÈÉ®ÁΩ≤ÊàêÂäü" >> $GITHUB_OUTPUT
            echo "details=ÊâÄÊúâÊúçÂä°Â∑≤ÊàêÂäüÊûÑÂª∫„ÄÅÈÉ®ÁΩ≤Âπ∂ÈÄöËøáÂÅ•Â∫∑Ê£ÄÊü•" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Sea-Saw ÂêéÁ´ØÈÉ®ÁΩ≤Â§±Ë¥•" >> $GITHUB_OUTPUT
            echo "details=ÈÉ®ÁΩ≤Èò∂ÊÆµÂ§±Ë¥•" >> $GITHUB_OUTPUT
          fi

      - name: Send WeChat Work notification
        env:
          WEBHOOK_URL: ${{ secrets.WECHAT_WEBHOOK_URL }}
        run: |
          if [ -n "$WEBHOOK_URL" ]; then
            echo "Sending WeChat Work notification..."
            curl -X POST "$WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d "{
                \"msgtype\": \"markdown\",
                \"markdown\": {
                  \"content\": \"## ${{ steps.status.outputs.message }}\n\n**È°πÁõÆ**: Sea-Saw Backend\n**Áä∂ÊÄÅ**: ${{ steps.status.outputs.details }}\n**ÂàÜÊîØ**: ${{ github.ref_name }}\n**Êèê‰∫§**: \`${{ github.sha }}\`\n**Êèê‰∫§ËÄÖ**: ${{ github.actor }}\n**Êó∂Èó¥**: $(date '+%Y-%m-%d %H:%M:%S')\n\n[Êü•ÁúãËØ¶ÊÉÖ](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\"
                }
              }"
          else
            echo "WeChat webhook not configured, skipping notification"
          fi

      - name: Send DingTalk notification
        env:
          WEBHOOK_URL: ${{ secrets.DINGTALK_WEBHOOK_URL }}
        run: |
          if [ -n "$WEBHOOK_URL" ]; then
            echo "Sending DingTalk notification..."
            curl -X POST "$WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d "{
                \"msgtype\": \"markdown\",
                \"markdown\": {
                  \"title\": \"${{ steps.status.outputs.message }}\",
                  \"text\": \"## ${{ steps.status.outputs.message }}\n\n**È°πÁõÆ**: Sea-Saw Backend\n\n**Áä∂ÊÄÅ**: ${{ steps.status.outputs.details }}\n\n**ÂàÜÊîØ**: ${{ github.ref_name }}\n\n**Êèê‰∫§**: ${{ github.sha }}\n\n**Êèê‰∫§ËÄÖ**: ${{ github.actor }}\n\n**Êó∂Èó¥**: $(date '+%Y-%m-%d %H:%M:%S')\n\n[Êü•ÁúãËØ¶ÊÉÖ](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\"
                }
              }"
          else
            echo "DingTalk webhook not configured, skipping notification"
          fi
